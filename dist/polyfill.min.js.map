{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "index.es6.js",
    "node_modules/assert/assert.js",
    "node_modules/better-assert/index.js",
    "node_modules/browserify/lib/_empty.js",
    "node_modules/callsite/index.js",
    "node_modules/process/browser.js",
    "node_modules/util/node_modules/inherits/inherits_browser.js",
    "node_modules/util/support/isBufferBrowser.js",
    "node_modules/util/util.js",
    "spec/reference-implementation/lib/byte-length-queuing-strategy.js",
    "spec/reference-implementation/lib/count-queuing-strategy.js",
    "spec/reference-implementation/lib/helpers.js",
    "spec/reference-implementation/lib/queue-with-sizes.js",
    "spec/reference-implementation/lib/readable-stream.js",
    "spec/reference-implementation/lib/transform-stream.js",
    "spec/reference-implementation/lib/writable-stream.js",
    "spec/reference-implementation/node_modules/debug/src/browser.js",
    "spec/reference-implementation/node_modules/debug/src/debug.js",
    "spec/reference-implementation/node_modules/ms/index.js"
  ],
  "names": [],
  "mappings": "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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "export const\n  { ReadableStream } = require('./spec/reference-implementation/lib/readable-stream'),\n  { WritableStream } = require('./spec/reference-implementation/lib/writable-stream'),\n  { ByteLengthQueuingStrategy } = require('./spec/reference-implementation/lib/byte-length-queuing-strategy'),\n  { CountQueuingStrategy } = require('./spec/reference-implementation/lib/count-queuing-strategy'),\n  { TransformStream } = require('./spec/reference-implementation/lib/transform-stream');\n\nconst interfaces = {\n  ReadableStream,\n  WritableStream,\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  TransformStream\n};\n\n// Export\nexport default interfaces;\n\nfunction getGlobals(){\n  if(typeof self !== 'undefined'){\n    return self;\n  }else if(typeof window !== 'undefined'){\n    return window;\n  }else if(typeof global !== 'undefined'){\n    return global;\n  }\n}\n\nfunction assignInterfaces(globals, interfaces){\n  for(let i in interfaces){\n    // prefer native implementation if available\n    if(typeof globals[i] === 'undefined'){\n      globals[i] = interfaces[i];\n    }else{\n      let _forcePolyfill = function(){\n        globals[i] = interfaces[i];\n      }\n      globals[i].forcePolyfill = _forcePolyfill;\n      globals[i].prototype.forcePolyfill = _forcePolyfill;\n    }\n  }\n}\n\nconst globals = getGlobals();\n// Add classes to window\nassignInterfaces(globals, interfaces);\n",
    "'use strict';\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util/');\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n",
    "/**\n * Module dependencies.\n */\n\nvar AssertionError = require('assert').AssertionError\n  , callsite = require('callsite')\n  , fs = require('fs')\n\n/**\n * Expose `assert`.\n */\n\nmodule.exports = process.env.NO_ASSERT\n  ? function(){}\n  : assert;\n\n/**\n * Assert the given `expr`.\n */\n\nfunction assert(expr) {\n  if (expr) return;\n\n  var stack = callsite();\n  var call = stack[1];\n  var file = call.getFileName();\n  var lineno = call.getLineNumber();\n  var src = fs.readFileSync(file, 'utf8');\n  var line = src.split('\\n')[lineno-1];\n  var src = line.match(/assert\\((.*)\\)/)[1];\n\n  var err = new AssertionError({\n    message: src,\n    stackStartFunction: stack[0].getFunction()\n  });\n\n  throw err;\n}\n",
    "\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIl9lbXB0eS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiZmlsZSI6Im91dC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiJdfQ==",
    "\nmodule.exports = function(){\n  var orig = Error.prepareStackTrace;\n  Error.prepareStackTrace = function(_, stack){ return stack; };\n  var err = new Error;\n  Error.captureStackTrace(err, arguments.callee);\n  var stack = err.stack;\n  Error.prepareStackTrace = orig;\n  return stack;\n};\n",
    "// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n",
    "if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n",
    "module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}",
    "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n",
    "'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class ByteLengthQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size(chunk) {\n    return chunk.byteLength;\n  }\n};\n",
    "'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class CountQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size() {\n    return 1;\n  }\n};\n",
    "'use strict';\nconst assert = require('better-assert');\n\nconst isFakeDetached = Symbol('is \"detached\" for our purposes');\n\nfunction IsPropertyKey(argument) {\n  return typeof argument === 'string' || typeof argument === 'symbol';\n}\n\nexports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';\n\nexports.createDataProperty = (o, p, v) => {\n  assert(exports.typeIsObject(o));\n  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });\n};\n\nexports.createArrayFromList = elements => {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice();\n};\n\nexports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n};\n\nexports.CreateIterResultObject = (value, done) => {\n  assert(typeof done === 'boolean');\n  const obj = {};\n  Object.defineProperty(obj, 'value', { value, enumerable: true, writable: true, configurable: true });\n  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });\n  return obj;\n};\n\nexports.IsFiniteNonNegativeNumber = v => {\n  if (exports.IsNonNegativeNumber(v) === false) {\n    return false;\n  }\n\n  if (v === Infinity) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.IsNonNegativeNumber = v => {\n  if (typeof v !== 'number') {\n    return false;\n  }\n\n  if (Number.isNaN(v)) {\n    return false;\n  }\n\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n};\n\nfunction Call(F, V, args) {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexports.Call = Call;\n\nexports.CreateAlgorithmFromUnderlyingMethod = (underlyingObject, methodName, algoArgCount, extraArgs) => {\n  assert(underlyingObject !== undefined);\n  assert(IsPropertyKey(methodName));\n  assert(algoArgCount === 0 || algoArgCount === 1);\n  assert(Array.isArray(extraArgs));\n  const method = underlyingObject[methodName];\n  if (method !== undefined) {\n    if (typeof method !== 'function') {\n      throw new TypeError(`${method} is not a method`);\n    }\n    switch (algoArgCount) {\n      case 0: {\n        return () => {\n          return PromiseCall(method, underlyingObject, extraArgs);\n        };\n      }\n\n      case 1: {\n        return arg => {\n          const fullArgs = [arg].concat(extraArgs);\n          return PromiseCall(method, underlyingObject, fullArgs);\n        };\n      }\n    }\n  }\n  return () => Promise.resolve();\n};\n\nexports.InvokeOrNoop = (O, P, args) => {\n  assert(O !== undefined);\n  assert(IsPropertyKey(P));\n  assert(Array.isArray(args));\n\n  const method = O[P];\n  if (method === undefined) {\n    return undefined;\n  }\n\n  return Call(method, O, args);\n};\n\nfunction PromiseCall(F, V, args) {\n  assert(typeof F === 'function');\n  assert(V !== undefined);\n  assert(Array.isArray(args));\n  try {\n    return Promise.resolve(Call(F, V, args));\n  } catch (value) {\n    return Promise.reject(value);\n  }\n}\n\nexports.PromiseCall = PromiseCall;\n\n// Not implemented correctly\nexports.TransferArrayBuffer = O => {\n  assert(!exports.IsDetachedBuffer(O));\n  const transferredIshVersion = O.slice();\n\n  // This is specifically to fool tests that test \"is transferred\" by taking a non-zero-length\n  // ArrayBuffer and checking if its byteLength starts returning 0.\n  Object.defineProperty(O, 'byteLength', {\n    get() {\n      return 0;\n    }\n  });\n  O[isFakeDetached] = true;\n\n  return transferredIshVersion;\n};\n\n// Not implemented correctly\nexports.IsDetachedBuffer = O => {\n  return isFakeDetached in O;\n};\n\nexports.ValidateAndNormalizeHighWaterMark = highWaterMark => {\n  highWaterMark = Number(highWaterMark);\n  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\n  }\n\n  return highWaterMark;\n};\n\nexports.MakeSizeAlgorithmFromSizeFunction = size => {\n  if (size === undefined) {\n    return () => 1;\n  }\n  if (typeof size !== 'function') {\n    throw new TypeError('size property of a queuing strategy must be a function');\n  }\n  return chunk => size(chunk);\n};\n",
    "'use strict';\nconst assert = require('better-assert');\nconst { IsFiniteNonNegativeNumber } = require('./helpers.js');\n\nexports.DequeueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift();\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n};\n\nexports.EnqueueValueWithSize = (container, value, size) => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  size = Number(size);\n  if (!IsFiniteNonNegativeNumber(size)) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n};\n\nexports.PeekQueueValue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue[0];\n  return pair.value;\n};\n\nexports.ResetQueue = container => {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = [];\n  container._queueTotalSize = 0;\n};\n",
    "'use strict';\nconst assert = require('better-assert');\nconst { ArrayBufferCopy, CreateAlgorithmFromUnderlyingMethod, CreateIterResultObject, IsFiniteNonNegativeNumber,\n        InvokeOrNoop, IsDetachedBuffer, TransferArrayBuffer, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, createArrayFromList, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, ResetQueue } = require('./queue-with-sizes.js');\nconst { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked,\n        WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation,\n        WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite, WritableStreamCloseQueuedOrInFlight } =\n      require('./writable-stream.js');\n\nconst CancelSteps = Symbol('[[CancelSteps]]');\nconst PullSteps = Symbol('[[PullSteps]]');\n\nclass ReadableStream {\n  constructor(underlyingSource = {}, { size, highWaterMark } = {}) {\n    InitializeReadableStream(this);\n    const type = underlyingSource.type;\n    const typeString = String(type);\n    if (typeString === 'bytes') {\n      if (highWaterMark === undefined) {\n        highWaterMark = 0;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      if (size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n\n      SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n    } else if (type === undefined) {\n      if (highWaterMark === undefined) {\n        highWaterMark = 1;\n      }\n      highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n      const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n    } else {\n      throw new RangeError('Invalid type is specified');\n    }\n  }\n\n  get locked() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  cancel(reason) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  getReader({ mode } = {}) {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    if (mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    mode = String(mode);\n\n    if (mode === 'byob') {\n      return AcquireReadableStreamBYOBReader(this);\n    }\n\n    throw new RangeError('Invalid mode is specified');\n  }\n\n  pipeThrough({ writable, readable }, options) {\n    if (writable === undefined || readable === undefined) {\n      throw new TypeError('readable and writable arguments must be defined');\n    }\n\n    const promise = this.pipeTo(writable, options);\n\n    ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise);\n\n    return readable;\n  }\n\n  pipeTo(dest, { preventClose, preventAbort, preventCancel } = {}) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('pipeTo'));\n    }\n    if (IsWritableStream(dest) === false) {\n      return Promise.reject(\n        new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\n    }\n\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n    }\n    if (IsWritableStreamLocked(dest) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n    }\n\n    const reader = AcquireReadableStreamDefaultReader(this);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n\n    let shuttingDown = false;\n\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = Promise.resolve();\n\n    return new Promise((resolve, reject) => {\n      // Using reader and writer, read all chunks from this and write them to dest\n      // - Backpressure must be enforced\n      // - Shutdown must stop all activity\n      function pipeLoop() {\n        if (shuttingDown === true) {\n          return Promise.resolve();\n        }\n\n        return writer._readyPromise.then(() => {\n          return ReadableStreamDefaultReaderRead(reader).then(({ value, done }) => {\n            if (done === true) {\n              return;\n            }\n\n            currentWrite = WritableStreamDefaultWriterWrite(writer, value).catch(() => {});\n          });\n        })\n        .then(pipeLoop);\n      }\n\n      // Errors must be propagated forward\n      isOrBecomesErrored(this, reader._closedPromise, storedError => {\n        if (preventAbort === false) {\n          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Errors must be propagated backward\n      isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Closing must be propagated forward\n      isOrBecomesClosed(this, reader._closedPromise, () => {\n        if (preventClose === false) {\n          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n        } else {\n          shutdown();\n        }\n      });\n\n      // Closing must be propagated backward\n      if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\n        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, destClosed), true, destClosed);\n        } else {\n          shutdown(true, destClosed);\n        }\n      }\n\n      pipeLoop().catch(err => {\n        currentWrite = Promise.resolve();\n        rethrowAssertionErrorRejection(err);\n      });\n\n      function waitForWritesToFinish() {\n        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n        // for that too.\n        const oldCurrentWrite = currentWrite;\n        return currentWrite.then(() => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n      }\n\n      function isOrBecomesErrored(stream, promise, action) {\n        if (stream._state === 'errored') {\n          action(stream._storedError);\n        } else {\n          promise.catch(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function isOrBecomesClosed(stream, promise, action) {\n        if (stream._state === 'closed') {\n          action();\n        } else {\n          promise.then(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function shutdownWithAction(action, originalIsError, originalError) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n          waitForWritesToFinish().then(doTheRest);\n        } else {\n          doTheRest();\n        }\n\n        function doTheRest() {\n          action().then(\n            () => finalize(originalIsError, originalError),\n            newError => finalize(true, newError)\n          )\n          .catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function shutdown(isError, error) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n          waitForWritesToFinish().then(() => finalize(isError, error)).catch(rethrowAssertionErrorRejection);\n        } else {\n          finalize(isError, error);\n        }\n      }\n\n      function finalize(isError, error) {\n        WritableStreamDefaultWriterRelease(writer);\n        ReadableStreamReaderGenericRelease(reader);\n\n        if (isError) {\n          reject(error);\n        } else {\n          resolve(undefined);\n        }\n      }\n    });\n  }\n\n  tee() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return createArrayFromList(branches);\n  }\n}\n\nmodule.exports = {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  ReadableStream,\n  IsReadableStreamDisturbed,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure,\n  ReadableStreamDefaultControllerCanCloseOrEnqueue\n};\n\n// Abstract operations for the ReadableStream.\n\nfunction AcquireReadableStreamBYOBReader(stream) {\n  return new ReadableStreamBYOBReader(stream);\n}\n\nfunction AcquireReadableStreamDefaultReader(stream) {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  SetUpReadableStreamDefaultController(\n      stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 0,\n                                  autoAllocateChunkSize = undefined) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  const stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nfunction IsReadableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDisturbed(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  return stream._disturbed;\n}\n\nfunction IsReadableStreamLocked(stream) {\n  assert(IsReadableStream(stream) === true);\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n  assert(IsReadableStream(stream) === true);\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader(stream);\n\n  let closedOrErrored = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1;\n  let reason2;\n  let branch1;\n  let branch2;\n\n  let resolveCancelPromise;\n  const cancelPromise = new Promise(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm() {\n    return ReadableStreamDefaultReaderRead(reader).then(result => {\n      assert(typeIsObject(result));\n      const value = result.value;\n      const done = result.done;\n      assert(typeof done === 'boolean');\n\n      if (done === true && closedOrErrored === false) {\n        if (canceled1 === false) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n        }\n        if (canceled2 === false) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n        }\n        closedOrErrored = true;\n      }\n\n      if (closedOrErrored === true) {\n        return;\n      }\n\n      const value1 = value;\n      const value2 = value;\n\n      // There is no way to access the cloning code right now in the reference implementation.\n      // If we add one then we'll need an implementation for serializable objects.\n      // if (canceled2 === false && cloneForBranch2 === true) {\n      //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n      // }\n\n      if (canceled1 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n      }\n\n      if (canceled2 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n      }\n    });\n  }\n\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1 === true) {\n      const compositeReason = createArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {}\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  reader._closedPromise.catch(r => {\n    if (closedOrErrored === true) {\n      return;\n    }\n\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n    closedOrErrored = true;\n  });\n\n  return [branch1, branch2];\n}\n\n// ReadableStream API exposed for controllers.\n\nfunction ReadableStreamAddReadIntoRequest(stream) {\n  assert(IsReadableStreamBYOBReader(stream._reader) === true);\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  const promise = new Promise((resolve, reject) => {\n    const readIntoRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._reader._readIntoRequests.push(readIntoRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamAddReadRequest(stream) {\n  assert(IsReadableStreamDefaultReader(stream._reader) === true);\n  assert(stream._state === 'readable');\n\n  const promise = new Promise((resolve, reject) => {\n    const readRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._reader._readRequests.push(readRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return sourceCancelPromise.then(() => undefined);\n}\n\nfunction ReadableStreamClose(stream) {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const { _resolve } of reader._readRequests) {\n      _resolve(CreateIterResultObject(undefined, true));\n    }\n    reader._readRequests = [];\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  return undefined;\n}\n\nfunction ReadableStreamError(stream, e) {\n  assert(IsReadableStream(stream) === true);\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const readRequest of reader._readRequests) {\n      readRequest._reject(e);\n    }\n\n    reader._readRequests = [];\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n\n    for (const readIntoRequest of reader._readIntoRequests) {\n      readIntoRequest._reject(e);\n    }\n\n    reader._readIntoRequests = [];\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n  reader._closedPromise.catch(() => {});\n}\n\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift();\n  readIntoRequest._resolve(CreateIterResultObject(chunk, done));\n}\n\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift();\n  readRequest._resolve(CreateIterResultObject(chunk, done));\n}\n\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n}\n\nfunction ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n}\n\nfunction ReadableStreamHasBYOBReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamBYOBReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamHasDefaultReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nclass ReadableStreamDefaultReader {\n  constructor(stream) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n    }\n    if (IsReadableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = [];\n  }\n\n  get closed() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    return ReadableStreamDefaultReaderRead(this);\n  }\n\n  releaseLock() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nclass ReadableStreamBYOBReader {\n  constructor(stream) {\n    if (!IsReadableStream(stream)) {\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\n          'byte source');\n    }\n    if (IsReadableByteStreamController(stream._readableStreamController) === false) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n          'source');\n    }\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = [];\n  }\n\n  get closed() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read(view) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return Promise.reject(new TypeError('view must be an array buffer view'));\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      return Promise.reject(new TypeError('Cannot read into a view onto a detached ArrayBuffer'));\n    }\n\n    if (view.byteLength === 0) {\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\n    }\n\n    return ReadableStreamBYOBReaderRead(this, view);\n  }\n\n  releaseLock() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\n// Abstract operations for the readers.\n\nfunction IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    reader._closedPromise.catch(() => {});\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nfunction ReadableStreamReaderGenericRelease(reader) {\n  assert(reader._ownerReadableStream !== undefined);\n  assert(reader._ownerReadableStream._reader === reader);\n\n  if (reader._ownerReadableStream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  }\n  reader._closedPromise.catch(() => {});\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n}\n\nfunction ReadableStreamBYOBReaderRead(reader, view) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  // Controllers must implement this.\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\n}\n\nfunction ReadableStreamDefaultReaderRead(reader) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(CreateIterResultObject(undefined, true));\n  }\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(stream._state === 'readable');\n\n  return stream._readableStreamController[PullSteps]();\n}\n\n// Controllers\n\nclass ReadableStreamDefaultController {\n  constructor() {\n    throw new TypeError();\n  }\n\n  get desiredSize() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    ResetQueue(this);\n    return this._cancelAlgorithm(reason);\n  }\n\n  [PullSteps]() {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested === true && this._queue.length === 0) {\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      return Promise.resolve(CreateIterResultObject(chunk, false));\n    }\n\n    const pendingPromise = ReadableStreamAddReadRequest(stream);\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    return pendingPromise;\n  }\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n      return undefined;\n    },\n    e => {\n      ReadableStreamDefaultControllerError(controller, e);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableStream;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction ReadableStreamDefaultControllerClose(controller) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamClose(stream);\n  }\n}\n\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableStream;\n\n  assert(ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === true);\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerError(controller, e) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue(controller);\n\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  const state = controller._controlledReadableStream._state;\n\n  if (controller._closeRequested === false && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nfunction SetUpReadableStreamDefaultController(\n  stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n    () => {\n      controller._started = true;\n\n      assert(controller._pulling === false);\n      assert(controller._pullAgain === false);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    },\n    r => {\n      ReadableStreamDefaultControllerError(controller, r);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark,\n                                                                  sizeAlgorithm) {\n  assert(underlyingSource !== undefined);\n\n  const controller = Object.create(ReadableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\n\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                       highWaterMark, sizeAlgorithm);\n}\n\nclass ReadableStreamBYOBRequest {\n  constructor() {\n    throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\n  }\n\n  get view() {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  respond(bytesWritten) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view.buffer) === true) {\n      throw new TypeError('The BYOB request\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  respondWithNewView(view) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (IsDetachedBuffer(view.buffer) === true) {\n      throw new TypeError('The supplied view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nclass ReadableByteStreamController {\n  constructor() {\n    throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\n  }\n\n  get byobRequest() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      const view = new Uint8Array(firstDescriptor.buffer,\n                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n      const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n      SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n      this._byobRequest = byobRequest;\n    }\n\n    return this._byobRequest;\n  }\n\n  get desiredSize() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n    }\n\n    if (IsDetachedBuffer(chunk.buffer) === true) {\n      throw new TypeError('Cannot enqueue a view onto a detached ArrayBuffer');\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  [CancelSteps](reason) {\n    if (this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      firstDescriptor.bytesFilled = 0;\n    }\n\n    ResetQueue(this);\n\n    return this._cancelAlgorithm(reason);\n  }\n\n  [PullSteps]() {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream) === true);\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      const entry = this._queue.shift();\n      this._queueTotalSize -= entry.byteLength;\n\n      ReadableByteStreamControllerHandleQueueDrain(this);\n\n      let view;\n      try {\n        view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n      } catch (viewE) {\n        return Promise.reject(viewE);\n      }\n\n      return Promise.resolve(CreateIterResultObject(view, false));\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        return Promise.reject(bufferE);\n      }\n\n      const pullIntoDescriptor = {\n        buffer,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        ctor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    const promise = ReadableStreamAddReadRequest(stream);\n\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n\n    return promise;\n  }\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nfunction IsReadableByteStreamController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      ReadableByteStreamControllerError(controller, e);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = [];\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  assert(stream._state !== 'errored');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.ctor(\n      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue[0];\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (ready === false) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === undefined) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = undefined;\n  controller._byobRequest = undefined;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  assert(controller._closeRequested === false);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos[0];\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerPullInto(controller, view) {\n  const stream = controller._controlledReadableByteStream;\n\n  let elementSize = 1;\n  if (view.constructor !== DataView) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n\n  const ctor = view.constructor;\n\n  const buffer = TransferArrayBuffer(view.buffer);\n  const pullIntoDescriptor = {\n    buffer,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize,\n    ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    return ReadableStreamAddReadIntoRequest(stream);\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new view.constructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    return Promise.resolve(CreateIterResultObject(emptyView, true));\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      return Promise.resolve(CreateIterResultObject(filledView, false));\n    }\n\n    if (controller._closeRequested === true) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      return Promise.reject(e);\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  const promise = ReadableStreamAddReadIntoRequest(stream);\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n\n  return promise;\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  assert(firstDescriptor.bytesFilled === 0);\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream) === true) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n    throw new RangeError('bytesWritten out of range');\n  }\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    // TODO: Figure out whether we should detach the buffer or not here.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(stream._state === 'readable');\n\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  const descriptor = controller._pendingPullIntos.shift();\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested === true) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {\n    return true;\n  }\n\n  return false;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nfunction ReadableByteStreamControllerClose(controller) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableStreamClose(stream);\n}\n\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableByteStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  const buffer = chunk.buffer;\n  const byteOffset = chunk.byteOffset;\n  const byteLength = chunk.byteLength;\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (ReadableStreamHasDefaultReader(stream) === true) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(IsReadableStreamLocked(stream) === false);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerError(controller, e) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n  const stream = controller._controlledReadableByteStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\n    throw new RangeError('bytesWritten must be a finite');\n  }\n\n  assert(controller._pendingPullIntos.length > 0);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.byteLength !== view.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n\n  firstDescriptor.buffer = view.buffer;\n\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\n\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm,\n                                           highWaterMark, autoAllocateChunkSize) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(Number.isInteger(autoAllocateChunkSize) === true);\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = [];\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  Promise.resolve(startResult).then(\n      () => {\n        controller._started = true;\n\n        assert(controller._pulling === false);\n        assert(controller._pullAgain === false);\n\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      },\n      r => {\n        ReadableByteStreamControllerError(controller, r);\n      }\n  )\n      .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n  assert(underlyingByteSource !== undefined);\n\n  const controller = Object.create(ReadableByteStreamController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\n  }\n\n  const pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\n  const cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\n\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize !== undefined) {\n    if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\n      throw new RangeError('autoAllocateChunkSize must be a positive integer');\n    }\n  }\n\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark,\n                                    autoAllocateChunkSize);\n}\n\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n  assert(IsReadableByteStreamController(controller) === true);\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view) === true);\n  assert(IsDetachedBuffer(view.buffer) === false);\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\n// Helper functions for the readers.\n\nfunction readerLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\nfunction defaultReaderClosedPromiseInitialize(reader) {\n  reader._closedPromise = new Promise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  reader._closedPromise = Promise.reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  reader._closedPromise = Promise.resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  reader._closedPromise = Promise.reject(reason);\n}\n\nfunction defaultReaderClosedPromiseResolve(reader) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction byobReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Helper function for ReadableStream pipeThrough\n\nfunction ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(promise) {\n  try {\n    // This relies on the brand-check that is enforced by Promise.prototype.then(). As with the rest of the reference\n    // implementation, it doesn't attempt to do the right thing if someone has modified the global environment.\n    Promise.prototype.then.call(promise, undefined, () => {});\n  } catch (e) {\n    // The brand check failed, therefore the internal slot is not present and there's nothing further to do.\n  }\n}\n",
    "'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:transform-stream:verbose');\nconst { InvokeOrNoop, CreateAlgorithmFromUnderlyingMethod, PromiseCall, typeIsObject,\n        ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction } = require('./helpers.js');\nconst { CreateReadableStream, ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue,\n        ReadableStreamDefaultControllerError, ReadableStreamDefaultControllerGetDesiredSize,\n        ReadableStreamDefaultControllerHasBackpressure,\n        ReadableStreamDefaultControllerCanCloseOrEnqueue } = require('./readable-stream.js');\nconst { CreateWritableStream, WritableStreamDefaultControllerErrorIfNeeded } = require('./writable-stream.js');\n\n// Class TransformStream\n\nclass TransformStream {\n  constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {\n    const readableType = transformer.readableType;\n\n    if (readableType !== undefined) {\n      throw new RangeError('Invalid readable type specified');\n    }\n\n    const writableType = transformer.writableType;\n\n    if (writableType !== undefined) {\n      throw new RangeError('Invalid writable type specified');\n    }\n\n    const writableSizeFunction = writableStrategy.size;\n    const writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\n    let writableHighWaterMark = writableStrategy.highWaterMark;\n    if (writableHighWaterMark === undefined) {\n      writableHighWaterMark = 1;\n    }\n    writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\n\n    const readableSizeFunction = readableStrategy.size;\n    const readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\n    let readableHighWaterMark = readableStrategy.highWaterMark;\n    if (readableHighWaterMark === undefined) {\n      readableHighWaterMark = 0;\n    }\n    readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\n\n    let startPromise_resolve;\n    const startPromise = new Promise(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                              readableSizeAlgorithm);\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    const startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\n    startPromise_resolve(startResult);\n  }\n\n  get readable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  get writable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\n// Transform Stream Abstract Operations\n\nfunction CreateTransformStream(startAlgorithm, transformAlgorithm, flushAlgorithm, writableHighWaterMark = 1,\n                               writableSizeAlgorithm = () => 1, readableHighWaterMark = 0,\n                               readableSizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve;\n  const startPromise = new Promise(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm,\n                                   readableHighWaterMark, readableSizeAlgorithm) {\n  function startAlgorithm() {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk) {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason) {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm() {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm() {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason) {\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n    return Promise.resolve();\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined;\n  stream._backpressureChangePromise = undefined;\n  stream._backpressureChangePromise_resolve = undefined;\n  TransformStreamSetBackpressure(stream, true);\n\n  // Used by IsWritableStream() which is called by SetUpTransformStreamDefaultController().\n  stream._transformStreamController = undefined;\n}\n\nfunction IsTransformStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n  verbose('TransformStreamError()');\n\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  if (stream._backpressure === true) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n  verbose(`TransformStreamSetBackpressure() [backpressure = ${backpressure}]`);\n\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = new Promise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\nclass TransformStreamDefaultController {\n  constructor() {\n    throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\n  }\n\n  get desiredSize() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n\n  enqueue(chunk) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(reason) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  terminate() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n  assert(IsTransformStream(stream) === true);\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n  assert(transformer !== undefined);\n\n  const controller = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm = chunk => {\n    try {\n      TransformStreamDefaultControllerEnqueue(controller, chunk);\n      return Promise.resolve();\n    } catch (transformResultE) {\n      return Promise.reject(transformResultE);\n    }\n  };\n  const transformMethod = transformer.transform;\n  if (transformMethod !== undefined) {\n    if (typeof transformMethod !== 'function') {\n      throw new TypeError('transform is not a method');\n    }\n    transformAlgorithm = chunk => {\n      const transformPromise = PromiseCall(transformMethod, transformer, [chunk, controller]);\n      return transformPromise.catch(e => {\n        TransformStreamError(stream, e);\n        throw e;\n      });\n    };\n  }\n\n  const flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  verbose('TransformStreamDefaultControllerEnqueue()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure === true);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller, e) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerTerminate(controller) {\n  verbose('TransformStreamDefaultControllerTerminate()');\n\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n    ReadableStreamDefaultControllerClose(readableController);\n  }\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n  verbose('TransformStreamDefaultSinkWriteAlgorithm()');\n\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure === true) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return backpressureChangePromise\n        .then(() => {\n          const writable = stream._writable;\n          const state = writable._state;\n          if (state === 'erroring') {\n            throw writable._storedError;\n          }\n          assert(state === 'writable');\n          return controller._transformAlgorithm(chunk);\n        });\n  }\n\n  return controller._transformAlgorithm(chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n  // errored.\n  TransformStreamError(stream, reason);\n  return Promise.resolve();\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n  verbose('TransformStreamDefaultSinkCloseAlgorithm()');\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  const flushPromise = stream._transformStreamController._flushAlgorithm();\n  // Return a promise that is fulfilled with undefined on success.\n  return flushPromise.then(() => {\n    if (readable._state === 'errored') {\n      throw readable._storedError;\n    }\n    const readableController = readable._readableStreamController;\n    if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n      ReadableStreamDefaultControllerClose(readableController);\n    }\n  }).catch(r => {\n    TransformStreamError(stream, r);\n    throw readable._storedError;\n  });\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n  verbose('TransformStreamDefaultSourcePullAlgorithm()');\n\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure === true);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\nmodule.exports = { CreateTransformStream, TransformStream };\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n",
    "'use strict';\nconst assert = require('better-assert');\n\n// Calls to verbose() are purely for debugging the reference implementation and tests. They are not part of the standard\n// and do not appear in the standard text.\nconst verbose = require('debug')('streams:writable-stream:verbose');\n\nconst { CreateAlgorithmFromUnderlyingMethod, InvokeOrNoop, ValidateAndNormalizeHighWaterMark, IsNonNegativeNumber,\n        MakeSizeAlgorithmFromSizeFunction, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, PeekQueueValue, ResetQueue } = require('./queue-with-sizes.js');\n\nconst AbortSteps = Symbol('[[AbortSteps]]');\nconst ErrorSteps = Symbol('[[ErrorSteps]]');\n\nclass WritableStream {\n  constructor(underlyingSink = {}, { size, highWaterMark = 1 } = {}) {\n    InitializeWritableStream(this);\n\n    const type = underlyingSink.type;\n\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  get locked() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  abort(reason) {\n    if (IsWritableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  getWriter() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nmodule.exports = {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter(stream) {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1,\n                              sizeAlgorithm = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark) === true);\n\n  const stream = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream(stream) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = [];\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsWritableStreamLocked(stream) {\n  assert(IsWritableStream(stream) === true);\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream, reason) {\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest._promise = promise;\n\n  if (wasAlreadyErroring === false) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream) {\n  assert(IsWritableStreamLocked(stream) === true);\n  assert(stream._state === 'writable');\n\n  const promise = new Promise((resolve, reject) => {\n    const writeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream, error) {\n  verbose('WritableStreamDealWithRejection(stream, %o)', error);\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream, reason) {\n  verbose('WritableStreamStartErroring(stream, %o)', reason);\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream) {\n  verbose('WritableStreamFinishErroring()');\n  assert(stream._state === 'erroring');\n  assert(WritableStreamHasOperationMarkedInFlight(stream) === false);\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  for (const writeRequest of stream._writeRequests) {\n    writeRequest._reject(storedError);\n  }\n  stream._writeRequests = [];\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring === true) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  promise.then(\n      () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      },\n      reason => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    verbose('WritableStreamHasOperationMarkedInFlight() is false');\n    return false;\n  }\n\n  verbose('WritableStreamHasOperationMarkedInFlight() is true');\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  verbose('WritableStreamRejectCloseAndClosedPromiseIfNeeded()');\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n    writer._closedPromise.catch(() => {});\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n  assert(stream._state === 'writable');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure === true) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(backpressure === false);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\nclass WritableStreamDefaultWriter {\n  constructor(stream) {\n    if (IsWritableStream(stream) === false) {\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\n    }\n    if (IsWritableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      this._readyPromise.catch(() => {});\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n      this._closedPromise.catch(() => {});\n    }\n  }\n\n  get closed() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  get desiredSize() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  get ready() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  abort(reason) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  close() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return Promise.reject(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  releaseLock() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  write(chunk) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.reject(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(WritableStreamCloseQueuedOrInFlight(stream) === false);\n\n  const promise = new Promise((resolve, reject) => {\n    const closeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  if (stream._backpressure === true && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.resolve();\n  }\n\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n  writer._closedPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  verbose('WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)', error);\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n  writer._readyPromise.catch(() => {});\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    'Writer was released and can no longer be used to monitor the stream\\'s closedness');\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined;\n}\n\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return Promise.reject(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n    return Promise.reject(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nclass WritableStreamDefaultController {\n  constructor() {\n    throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\n  }\n\n  error(e) {\n    if (IsWritableStreamDefaultController(this) === false) {\n      throw new TypeError(\n        'WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  [AbortSteps](reason) {\n    return this._abortAlgorithm(reason);\n  }\n\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                              abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  assert(IsWritableStream(stream) === true);\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = Promise.resolve(startResult);\n  startPromise.then(\n      () => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      },\n      r => {\n        assert(stream._state === 'writable' || stream._state === 'erroring');\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n      }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n  assert(underlyingSink !== undefined);\n\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  function startAlgorithm() {\n    return InvokeOrNoop(underlyingSink, 'start', [controller]);\n  }\n\n  const writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\n  const closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\n  const abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n\nfunction WritableStreamDefaultControllerClose(controller) {\n  EnqueueValueWithSize(controller, 'close', 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n  const writeRecord = { chunk };\n\n  try {\n    EnqueueValueWithSize(controller, writeRecord, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  verbose('WritableStreamDefaultControllerAdvanceQueueIfNeeded()');\n  const stream = controller._controlledWritableStream;\n\n  if (controller._started === false) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return;\n  }\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const writeRecord = PeekQueueValue(controller);\n  if (writeRecord === 'close') {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  sinkClosePromise.then(\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  sinkWritePromise.then(\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    reason => {\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller, error) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name) {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer) {\n  writer._closedPromise = new Promise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  writer._closedPromise = Promise.resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResolve(writer) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer) {\n  verbose('defaultWriterReadyPromiseInitialize()');\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseInitializeAsRejected(writer, %o)', reason);\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  verbose('defaultWriterReadyPromiseInitializeAsResolved()');\n  writer._readyPromise = Promise.resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n  verbose('defaultWriterReadyPromiseReject(writer, %o)', reason);\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer) {\n  verbose('defaultWriterReadyPromiseReset()');\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n  verbose('defaultWriterReadyPromiseResetToRejected(writer, %o)', reason);\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = Promise.reject(reason);\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseResolve(writer) {\n  verbose('defaultWriterReadyPromiseResolve()');\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n",
    "/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n",
    "\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n",
    "/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n"
  ]
}