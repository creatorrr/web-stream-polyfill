{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "index.es6.js",
    "node_modules/browserify/lib/_empty.js",
    "spec/reference-implementation/lib/byte-length-queuing-strategy.js",
    "spec/reference-implementation/lib/count-queuing-strategy.js",
    "spec/reference-implementation/lib/helpers.js",
    "spec/reference-implementation/lib/queue-with-sizes.js",
    "spec/reference-implementation/lib/readable-stream.js",
    "spec/reference-implementation/lib/transform-stream.js",
    "spec/reference-implementation/lib/writable-stream.js"
  ],
  "names": [],
  "mappings": "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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "const\n  { ReadableStream } = require('./spec/reference-implementation/lib/readable-stream'),\n  { WritableStream } = require('./spec/reference-implementation/lib/writable-stream'),\n  { ByteLengthQueuingStrategy } = require('./spec/reference-implementation/lib/byte-length-queuing-strategy'),\n  { CountQueuingStrategy } = require('./spec/reference-implementation/lib/count-queuing-strategy'),\n  { TransformStream } = require('./spec/reference-implementation/lib/transform-stream');\n\nconst interfaces = {\n  ReadableStream,\n  WritableStream,\n  ByteLengthQueuingStrategy,\n  CountQueuingStrategy,\n  TransformStream\n};\n\n// Export\nexport default interfaces;\n\nfunction getGlobals(){\n  if(typeof self !== 'undefined'){\n    return self;\n  }else if(typeof window !== 'undefined'){\n    return window;\n  }else if(typeof global !== 'undefined'){\n    return global;\n  }\n}\n\nfunction assignInterfaces(globals, interfaces){\n  for(let i in interfaces){\n    // prefer native implementation if available\n    if(typeof self[i] === 'undefined'){\n      globals[i] = interfaces[i];\n    }\n  }  \n}\n\nconst globals = getGlobals();\n// Add classes to window\nassignInterfaces(globals, interfaces);\n",
    "\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIl9lbXB0eS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwiZmlsZSI6Im91dC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiJdfQ==",
    "'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class ByteLengthQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size(chunk) {\n    return chunk.byteLength;\n  }\n};\n",
    "'use strict';\nconst { createDataProperty } = require('./helpers.js');\n\nmodule.exports = class CountQueuingStrategy {\n  constructor({ highWaterMark }) {\n    createDataProperty(this, 'highWaterMark', highWaterMark);\n  }\n\n  size() {\n    return 1;\n  }\n};\n",
    "'use strict';\nconst assert = require('assert');\n\nfunction IsPropertyKey(argument) {\n  return typeof argument === 'string' || typeof argument === 'symbol';\n}\n\nexports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';\n\nexports.createDataProperty = (o, p, v) => {\n  assert(exports.typeIsObject(o));\n  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });\n};\n\nexports.createArrayFromList = elements => {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice();\n};\n\nexports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n};\n\nexports.CreateIterResultObject = (value, done) => {\n  assert(typeof done === 'boolean');\n  const obj = {};\n  Object.defineProperty(obj, 'value', { value, enumerable: true, writable: true, configurable: true });\n  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });\n  return obj;\n};\n\nexports.IsFiniteNonNegativeNumber = v => {\n  if (Number.isNaN(v)) {\n    return false;\n  }\n  if (v === Infinity) {\n    return false;\n  }\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n};\n\nfunction Call(F, V, args) {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexports.InvokeOrNoop = (O, P, args) => {\n  assert(O !== undefined);\n  assert(IsPropertyKey(P));\n  assert(Array.isArray(args));\n\n  const method = O[P];\n  if (method === undefined) {\n    return undefined;\n  }\n\n  return Call(method, O, args);\n};\n\nexports.PromiseInvokeOrNoop = (O, P, args) => {\n  assert(O !== undefined);\n  assert(IsPropertyKey(P));\n  assert(Array.isArray(args));\n  try {\n    return Promise.resolve(exports.InvokeOrNoop(O, P, args));\n  } catch (returnValueE) {\n    return Promise.reject(returnValueE);\n  }\n};\n\nexports.PromiseInvokeOrPerformFallback = (O, P, args, F, argsF) => {\n  assert(O !== undefined);\n  assert(IsPropertyKey(P));\n  assert(Array.isArray(args));\n  assert(Array.isArray(argsF));\n\n  let method;\n  try {\n    method = O[P];\n  } catch (methodE) {\n    return Promise.reject(methodE);\n  }\n\n  if (method === undefined) {\n    return F(...argsF);\n  }\n\n  try {\n    return Promise.resolve(Call(method, O, args));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nexports.PromiseInvokeOrFallbackOrNoop = (O, P1, args1, P2, args2) => {\n  assert(O !== undefined);\n  assert(IsPropertyKey(P1));\n  assert(Array.isArray(args1));\n  assert(IsPropertyKey(P2));\n  assert(Array.isArray(args2));\n\n  return exports.PromiseInvokeOrPerformFallback(O, P1, args1, exports.PromiseInvokeOrNoop, [O, P2, args2]);\n};\n\n// Not implemented correctly\nexports.SameRealmTransfer = O => O;\n\nexports.ValidateAndNormalizeHighWaterMark = highWaterMark => {\n  highWaterMark = Number(highWaterMark);\n  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\n  }\n\n  return highWaterMark;\n};\n\nexports.ValidateAndNormalizeQueuingStrategy = (size, highWaterMark) => {\n  if (size !== undefined && typeof size !== 'function') {\n    throw new TypeError('size property of a queuing strategy must be a function');\n  }\n\n  highWaterMark = exports.ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n  return { size, highWaterMark };\n};\n",
    "'use strict';\nconst assert = require('assert');\nconst { IsFiniteNonNegativeNumber } = require('./helpers.js');\n\nexports.DequeueValue = queue => {\n  assert(queue.length > 0, 'Spec-level failure: should never dequeue from an empty queue.');\n  const pair = queue.shift();\n\n  queue._totalSize -= pair.size;\n\n  return pair.value;\n};\n\nexports.EnqueueValueWithSize = (queue, value, size) => {\n  size = Number(size);\n  if (!IsFiniteNonNegativeNumber(size)) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  queue.push({ value, size });\n\n  if (queue._totalSize === undefined) {\n    queue._totalSize = 0;\n  }\n  queue._totalSize += size;\n};\n\n// This implementation is not per-spec. Total size is cached for speed.\nexports.GetTotalQueueSize = queue => {\n  if (queue._totalSize === undefined) {\n    queue._totalSize = 0;\n  }\n  return queue._totalSize;\n};\n\nexports.PeekQueueValue = queue => {\n  assert(queue.length > 0, 'Spec-level failure: should never peek at an empty queue.');\n  const pair = queue[0];\n  return pair.value;\n};\n",
    "'use strict';\nconst assert = require('assert');\nconst { ArrayBufferCopy, CreateIterResultObject, IsFiniteNonNegativeNumber, InvokeOrNoop, PromiseInvokeOrNoop,\n        SameRealmTransfer, ValidateAndNormalizeQueuingStrategy, ValidateAndNormalizeHighWaterMark } =\n      require('./helpers.js');\nconst { createArrayFromList, createDataProperty, typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, GetTotalQueueSize } = require('./queue-with-sizes.js');\nconst { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked,\n        WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation,\n        WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite } = require('./writable-stream.js');\n\nconst InternalCancel = Symbol('[[Cancel]]');\nconst InternalPull = Symbol('[[Pull]]');\n\nclass ReadableStream {\n  constructor(underlyingSource = {}, { size, highWaterMark } = {}) {\n    // Exposed to controllers.\n    this._state = 'readable';\n\n    this._reader = undefined;\n    this._storedError = undefined;\n\n    this._disturbed = false;\n\n    // Initialize to undefined first because the constructor of the controller checks this\n    // variable to validate the caller.\n    this._readableStreamController = undefined;\n    const type = underlyingSource.type;\n    const typeString = String(type);\n    if (typeString === 'bytes') {\n      if (highWaterMark === undefined) {\n        highWaterMark = 0;\n      }\n      this._readableStreamController = new ReadableByteStreamController(this, underlyingSource, highWaterMark);\n    } else if (type === undefined) {\n      if (highWaterMark === undefined) {\n        highWaterMark = 1;\n      }\n      this._readableStreamController = new ReadableStreamDefaultController(this, underlyingSource, size, highWaterMark);\n    } else {\n      throw new RangeError('Invalid type is specified');\n    }\n  }\n\n  get locked() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  cancel(reason) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  getReader({ mode } = {}) {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    if (mode === 'byob') {\n      if (IsReadableByteStreamController(this._readableStreamController) === false) {\n        throw new TypeError('Cannot get a ReadableStreamBYOBReader for a stream not constructed with a byte source');\n      }\n\n      return AcquireReadableStreamBYOBReader(this);\n    }\n\n    if (mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    throw new RangeError('Invalid mode is specified');\n  }\n\n  pipeThrough({ writable, readable }, options) {\n    this.pipeTo(writable, options);\n    return readable;\n  }\n\n  pipeTo(dest, { preventClose, preventAbort, preventCancel } = {}) {\n    if (IsReadableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('pipeTo'));\n    }\n    if (IsWritableStream(dest) === false) {\n      return Promise.reject(\n        new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\n    }\n\n    preventClose = Boolean(preventClose);\n    preventAbort = Boolean(preventAbort);\n    preventCancel = Boolean(preventCancel);\n\n    if (IsReadableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n    }\n    if (IsWritableStreamLocked(dest) === true) {\n      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n    }\n\n    const reader = AcquireReadableStreamDefaultReader(this);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n\n    let shuttingDown = false;\n\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = Promise.resolve();\n\n    return new Promise((resolve, reject) => {\n      // Using reader and writer, read all chunks from this and write them to dest\n      // - Backpressure must be enforced\n      // - Shutdown must stop all activity\n      function pipeLoop() {\n        currentWrite = Promise.resolve();\n\n        if (shuttingDown === true) {\n          return Promise.resolve();\n        }\n\n        return writer._readyPromise.then(() => {\n          return ReadableStreamDefaultReaderRead(reader).then(({ value, done }) => {\n            if (done === true) {\n              return undefined;\n            }\n\n            currentWrite = WritableStreamDefaultWriterWrite(writer, value);\n            return currentWrite;\n          });\n        })\n        .then(pipeLoop);\n      }\n\n      // Errors must be propagated forward\n      isOrBecomesErrored(this, reader._closedPromise, storedError => {\n        if (preventAbort === false) {\n          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Errors must be propagated backward\n      isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, storedError), true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      });\n\n      // Closing must be propagated forward\n      isOrBecomesClosed(this, reader._closedPromise, () => {\n        if (preventClose === false) {\n          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n        } else {\n          shutdown();\n        }\n      });\n\n      // Closing must be propagated backward\n      if (dest._state === 'closing' || dest._state === 'closed') {\n        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n        if (preventCancel === false) {\n          shutdownWithAction(() => ReadableStreamCancel(this, destClosed), true, destClosed);\n        } else {\n          shutdown(true, destClosed);\n        }\n      }\n\n      pipeLoop().catch(err => {\n        currentWrite = Promise.resolve();\n        rethrowAssertionErrorRejection(err);\n      });\n\n      function isOrBecomesErrored(stream, promise, action) {\n        if (stream._state === 'errored') {\n          action(stream._storedError);\n        } else {\n          promise.catch(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function isOrBecomesClosed(stream, promise, action) {\n        if (stream._state === 'closed') {\n          action();\n        } else {\n          promise.then(action).catch(rethrowAssertionErrorRejection);\n        }\n      }\n\n      function waitForCurrentWrite() {\n        return currentWrite.catch(() => {});\n      }\n\n      function shutdownWithAction(action, originalIsError, originalError) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        waitForCurrentWrite().then(() => {\n          return action().then(\n            () => finalize(originalIsError, originalError),\n            newError => finalize(true, newError)\n          );\n        })\n        .catch(rethrowAssertionErrorRejection);\n      }\n\n      function shutdown(isError, error) {\n        if (shuttingDown === true) {\n          return;\n        }\n        shuttingDown = true;\n\n        waitForCurrentWrite().then(() => {\n          finalize(isError, error);\n        })\n        .catch(rethrowAssertionErrorRejection);\n      }\n\n      function finalize(isError, error) {\n        WritableStreamDefaultWriterRelease(writer);\n        ReadableStreamReaderGenericRelease(reader);\n\n        if (isError) {\n          reject(error);\n        } else {\n          resolve(undefined);\n        }\n      }\n    });\n  }\n\n  tee() {\n    if (IsReadableStream(this) === false) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return createArrayFromList(branches);\n  }\n}\n\nmodule.exports = {\n  ReadableStream,\n  IsReadableStreamDisturbed,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize\n};\n\n// Abstract operations for the ReadableStream.\n\nfunction AcquireReadableStreamBYOBReader(stream) {\n  return new ReadableStreamBYOBReader(stream);\n}\n\nfunction AcquireReadableStreamDefaultReader(stream) {\n  return new ReadableStreamDefaultReader(stream);\n}\n\nfunction IsReadableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDisturbed(stream) {\n  assert(IsReadableStream(stream) === true, 'IsReadableStreamDisturbed should only be used on known readable streams');\n\n  return stream._disturbed;\n}\n\nfunction IsReadableStreamLocked(stream) {\n  assert(IsReadableStream(stream) === true, 'IsReadableStreamLocked should only be used on known readable streams');\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n  assert(IsReadableStream(stream) === true);\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader(stream);\n\n  const teeState = {\n    closedOrErrored: false,\n    canceled1: false,\n    canceled2: false,\n    reason1: undefined,\n    reason2: undefined\n  };\n  teeState.promise = new Promise(resolve => {\n    teeState._resolve = resolve;\n  });\n\n  const pull = create_ReadableStreamTeePullFunction();\n  pull._reader = reader;\n  pull._teeState = teeState;\n  pull._cloneForBranch2 = cloneForBranch2;\n\n  const cancel1 = create_ReadableStreamTeeBranch1CancelFunction();\n  cancel1._stream = stream;\n  cancel1._teeState = teeState;\n\n  const cancel2 = create_ReadableStreamTeeBranch2CancelFunction();\n  cancel2._stream = stream;\n  cancel2._teeState = teeState;\n\n  const underlyingSource1 = Object.create(Object.prototype);\n  createDataProperty(underlyingSource1, 'pull', pull);\n  createDataProperty(underlyingSource1, 'cancel', cancel1);\n  const branch1Stream = new ReadableStream(underlyingSource1);\n\n  const underlyingSource2 = Object.create(Object.prototype);\n  createDataProperty(underlyingSource2, 'pull', pull);\n  createDataProperty(underlyingSource2, 'cancel', cancel2);\n  const branch2Stream = new ReadableStream(underlyingSource2);\n\n  pull._branch1 = branch1Stream._readableStreamController;\n  pull._branch2 = branch2Stream._readableStreamController;\n\n  reader._closedPromise.catch(r => {\n    if (teeState.closedOrErrored === true) {\n      return;\n    }\n\n    ReadableStreamDefaultControllerError(pull._branch1, r);\n    ReadableStreamDefaultControllerError(pull._branch2, r);\n    teeState.closedOrErrored = true;\n  });\n\n  return [branch1Stream, branch2Stream];\n}\n\nfunction create_ReadableStreamTeePullFunction() {\n  function f() {\n    const { _reader: reader, _branch1: branch1, _branch2: branch2, _teeState: teeState/* ,\n            _cloneForBranch2: cloneForBranch2*/ } = f;\n\n    return ReadableStreamDefaultReaderRead(reader).then(result => {\n      assert(typeIsObject(result));\n      const value = result.value;\n      const done = result.done;\n      assert(typeof done === 'boolean');\n\n      if (done === true && teeState.closedOrErrored === false) {\n        if (teeState.canceled1 === false) {\n          ReadableStreamDefaultControllerClose(branch1);\n        }\n        if (teeState.canceled2 === false) {\n          ReadableStreamDefaultControllerClose(branch2);\n        }\n        teeState.closedOrErrored = true;\n      }\n\n      if (teeState.closedOrErrored === true) {\n        return;\n      }\n\n      const value1 = value;\n      const value2 = value;\n\n      // There is no way to access the cloning code right now in the reference implementation.\n      // If we add one then we'll need an implementation for StructuredClone.\n      // if (teeState.canceled2 === false && cloneForBranch2 === true) {\n      //   value2 = StructuredClone(value2);\n      // }\n\n      if (teeState.canceled1 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch1, value1);\n      }\n\n      if (teeState.canceled2 === false) {\n        ReadableStreamDefaultControllerEnqueue(branch2, value2);\n      }\n    });\n  }\n  return f;\n}\n\nfunction create_ReadableStreamTeeBranch1CancelFunction() {\n  function f(reason) {\n    const { _stream: stream, _teeState: teeState } = f;\n\n    teeState.canceled1 = true;\n    teeState.reason1 = reason;\n    if (teeState.canceled2 === true) {\n      const compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      teeState._resolve(cancelResult);\n    }\n    return teeState.promise;\n  }\n  return f;\n}\n\nfunction create_ReadableStreamTeeBranch2CancelFunction() {\n  function f(reason) {\n    const { _stream: stream, _teeState: teeState } = f;\n\n    teeState.canceled2 = true;\n    teeState.reason2 = reason;\n    if (teeState.canceled1 === true) {\n      const compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      teeState._resolve(cancelResult);\n    }\n    return teeState.promise;\n  }\n  return f;\n}\n\n// ReadableStream API exposed for controllers.\n\nfunction ReadableStreamAddReadIntoRequest(stream) {\n  assert(IsReadableStreamBYOBReader(stream._reader) === true);\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  const promise = new Promise((resolve, reject) => {\n    const readIntoRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._reader._readIntoRequests.push(readIntoRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamAddReadRequest(stream) {\n  assert(IsReadableStreamDefaultReader(stream._reader) === true);\n  assert(stream._state === 'readable');\n\n  const promise = new Promise((resolve, reject) => {\n    const readRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._reader._readRequests.push(readRequest);\n  });\n\n  return promise;\n}\n\nfunction ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const sourceCancelPromise = stream._readableStreamController[InternalCancel](reason);\n  return sourceCancelPromise.then(() => undefined);\n}\n\nfunction ReadableStreamClose(stream) {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const { _resolve } of reader._readRequests) {\n      _resolve(CreateIterResultObject(undefined, true));\n    }\n    reader._readRequests = [];\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  return undefined;\n}\n\nfunction ReadableStreamError(stream, e) {\n  assert(IsReadableStream(stream) === true, 'stream must be ReadableStream');\n  assert(stream._state === 'readable', 'state must be readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return undefined;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === true) {\n    for (const readRequest of reader._readRequests) {\n      readRequest._reject(e);\n    }\n\n    reader._readRequests = [];\n  } else {\n    assert(IsReadableStreamBYOBReader(reader), 'reader must be ReadableStreamBYOBReader');\n\n    for (const readIntoRequest of reader._readIntoRequests) {\n      readIntoRequest._reject(e);\n    }\n\n    reader._readIntoRequests = [];\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n  reader._closedPromise.catch(() => {});\n}\n\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift();\n  readIntoRequest._resolve(CreateIterResultObject(chunk, done));\n}\n\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  const reader = stream._reader;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift();\n  readRequest._resolve(CreateIterResultObject(chunk, done));\n}\n\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n}\n\nfunction ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n}\n\nfunction ReadableStreamHasBYOBReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamBYOBReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamHasDefaultReader(stream) {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (IsReadableStreamDefaultReader(reader) === false) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nclass ReadableStreamDefaultReader {\n  constructor(stream) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n    }\n    if (IsReadableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = [];\n  }\n\n  get closed() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      return Promise.reject(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    return ReadableStreamDefaultReaderRead(this);\n  }\n\n  releaseLock() {\n    if (IsReadableStreamDefaultReader(this) === false) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nclass ReadableStreamBYOBReader {\n  constructor(stream) {\n    if (!IsReadableStream(stream)) {\n      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +\n          'byte source');\n    }\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = [];\n  }\n\n  get closed() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  cancel(reason) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  read(view) {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return Promise.reject(byobReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return Promise.reject(readerLockException('read from'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return Promise.reject(new TypeError('view must be an array buffer view'));\n    }\n\n    if (view.byteLength === 0) {\n      return Promise.reject(new TypeError('view must have non-zero byteLength'));\n    }\n\n    return ReadableStreamBYOBReaderRead(this, view);\n  }\n\n  releaseLock() {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\n// Abstract operations for the readers.\n\nfunction IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored', 'state must be errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    reader._closedPromise.catch(() => {});\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nfunction ReadableStreamReaderGenericRelease(reader) {\n  assert(reader._ownerReadableStream !== undefined);\n  assert(reader._ownerReadableStream._reader === reader);\n\n  if (reader._ownerReadableStream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n        reader,\n        new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  }\n  reader._closedPromise.catch(() => {});\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n}\n\nfunction ReadableStreamBYOBReaderRead(reader, view) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  // Controllers must implement this.\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\n}\n\nfunction ReadableStreamDefaultReaderRead(reader) {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return Promise.resolve(CreateIterResultObject(undefined, true));\n  }\n\n  if (stream._state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(stream._state === 'readable');\n\n  return stream._readableStreamController[InternalPull]();\n}\n\n// Controllers\n\nclass ReadableStreamDefaultController {\n  constructor(stream, underlyingSource, size, highWaterMark) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableStreamDefaultController can only be constructed with a ReadableStream instance');\n    }\n\n    if (stream._readableStreamController !== undefined) {\n      throw new TypeError(\n        'ReadableStreamDefaultController instances can only be created by the ReadableStream constructor');\n    }\n\n    this._controlledReadableStream = stream;\n\n    this._underlyingSource = underlyingSource;\n\n    this._queue = [];\n    this._started = false;\n    this._closeRequested = false;\n    this._pullAgain = false;\n    this._pulling = false;\n\n    const normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);\n    this._strategySize = normalizedStrategy.size;\n    this._strategyHWM = normalizedStrategy.highWaterMark;\n\n    const controller = this;\n\n    const startResult = InvokeOrNoop(underlyingSource, 'start', [this]);\n    Promise.resolve(startResult).then(\n      () => {\n        controller._started = true;\n\n        assert(controller._pulling === false);\n        assert(controller._pullAgain === false);\n\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      },\n      r => {\n        ReadableStreamDefaultControllerErrorIfNeeded(controller, r);\n      }\n    )\n    .catch(rethrowAssertionErrorRejection);\n  }\n\n  get desiredSize() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    const stream = this._controlledReadableStream;\n    if (stream._state !== 'readable') {\n      throw new TypeError(`The stream is ${stream._state} and so cannot be errored`);\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  [InternalCancel](reason) {\n    this._queue = [];\n\n    return PromiseInvokeOrNoop(this._underlyingSource, 'cancel', [reason]);\n  }\n\n  [InternalPull]() {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this._queue);\n\n      if (this._closeRequested === true && this._queue.length === 0) {\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      return Promise.resolve(CreateIterResultObject(chunk, false));\n    }\n\n    const pendingPromise = ReadableStreamAddReadRequest(stream);\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    return pendingPromise;\n  }\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_underlyingSource')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  const pullPromise = PromiseInvokeOrNoop(controller._underlyingSource, 'pull', [controller]);\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n      return undefined;\n    },\n    e => {\n      ReadableStreamDefaultControllerErrorIfNeeded(controller, e);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state === 'closed' || stream._state === 'errored') {\n    return false;\n  }\n\n  if (controller._closeRequested === true) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  if (desiredSize > 0) {\n    return true;\n  }\n\n  return false;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction ReadableStreamDefaultControllerClose(controller) {\n  const stream = controller._controlledReadableStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamClose(stream);\n  }\n}\n\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize = 1;\n\n    if (controller._strategySize !== undefined) {\n      try {\n        chunkSize = controller._strategySize(chunk);\n      } catch (chunkSizeE) {\n        ReadableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n        throw chunkSizeE;\n      }\n    }\n\n    try {\n      EnqueueValueWithSize(controller._queue, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n\n  return undefined;\n}\n\nfunction ReadableStreamDefaultControllerError(controller, e) {\n  const stream = controller._controlledReadableStream;\n\n  assert(stream._state === 'readable');\n\n  controller._queue = [];\n\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableStreamDefaultControllerErrorIfNeeded(controller, e) {\n  if (controller._controlledReadableStream._state === 'readable') {\n    ReadableStreamDefaultControllerError(controller, e);\n  }\n}\n\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  const queueSize = GetTotalQueueSize(controller._queue);\n  return controller._strategyHWM - queueSize;\n}\n\nclass ReadableStreamBYOBRequest {\n  constructor(controller, view) {\n    this._associatedReadableByteStreamController = controller;\n    this._view = view;\n  }\n\n  get view() {\n    return this._view;\n  }\n\n  respond(bytesWritten) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  respondWithNewView(view) {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n      throw byobRequestBrandCheckException('respond');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nclass ReadableByteStreamController {\n  constructor(stream, underlyingByteSource, highWaterMark) {\n    if (IsReadableStream(stream) === false) {\n      throw new TypeError('ReadableByteStreamController can only be constructed with a ReadableStream instance given ' +\n          'a byte source');\n    }\n\n    if (stream._readableStreamController !== undefined) {\n      throw new TypeError(\n          'ReadableByteStreamController instances can only be created by the ReadableStream constructor given a byte ' +\n              'source');\n    }\n\n    this._controlledReadableStream = stream;\n\n    this._underlyingByteSource = underlyingByteSource;\n\n    this._pullAgain = false;\n    this._pulling = false;\n\n    ReadableByteStreamControllerClearPendingPullIntos(this);\n\n    this._queue = [];\n    this._totalQueuedBytes = 0;\n\n    this._closeRequested = false;\n\n    this._started = false;\n\n    this._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n\n    const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\n        throw new RangeError('autoAllocateChunkSize must be a positive integer');\n      }\n    }\n    this._autoAllocateChunkSize = autoAllocateChunkSize;\n\n    this._pendingPullIntos = [];\n\n    const controller = this;\n\n    const startResult = InvokeOrNoop(underlyingByteSource, 'start', [this]);\n    Promise.resolve(startResult).then(\n      () => {\n        controller._started = true;\n\n        assert(controller._pulling === false);\n        assert(controller._pullAgain === false);\n\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      },\n      r => {\n        if (stream._state === 'readable') {\n          ReadableByteStreamControllerError(controller, r);\n        }\n      }\n    )\n    .catch(rethrowAssertionErrorRejection);\n  }\n\n  get byobRequest() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      const view = new Uint8Array(firstDescriptor.buffer,\n                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n      this._byobRequest = new ReadableStreamBYOBRequest(this, view);\n    }\n\n    return this._byobRequest;\n  }\n\n  get desiredSize() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  enqueue(chunk) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    if (this._closeRequested === true) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  error(e) {\n    if (IsReadableByteStreamController(this) === false) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    const stream = this._controlledReadableStream;\n    if (stream._state !== 'readable') {\n      throw new TypeError(`The stream is ${stream._state} and so cannot be errored`);\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  [InternalCancel](reason) {\n    if (this._pendingPullIntos.length > 0) {\n      const firstDescriptor = this._pendingPullIntos[0];\n      firstDescriptor.bytesFilled = 0;\n    }\n\n    this._queue = [];\n    this._totalQueuedBytes = 0;\n\n    return PromiseInvokeOrNoop(this._underlyingByteSource, 'cancel', [reason]);\n  }\n\n  [InternalPull]() {\n    const stream = this._controlledReadableStream;\n\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      if (this._totalQueuedBytes > 0) {\n        const entry = this._queue.shift();\n        this._totalQueuedBytes -= entry.byteLength;\n\n        ReadableByteStreamControllerHandleQueueDrain(this);\n\n        let view;\n        try {\n          view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n        } catch (viewE) {\n          return Promise.reject(viewE);\n        }\n\n        return Promise.resolve(CreateIterResultObject(view, false));\n      }\n\n      const autoAllocateChunkSize = this._autoAllocateChunkSize;\n      if (autoAllocateChunkSize !== undefined) {\n        let buffer;\n        try {\n          buffer = new ArrayBuffer(autoAllocateChunkSize);\n        } catch (bufferE) {\n          return Promise.reject(bufferE);\n        }\n\n        const pullIntoDescriptor = {\n          buffer,\n          byteOffset: 0,\n          byteLength: autoAllocateChunkSize,\n          bytesFilled: 0,\n          elementSize: 1,\n          ctor: Uint8Array,\n          readerType: 'default'\n        };\n\n        this._pendingPullIntos.push(pullIntoDescriptor);\n      }\n    } else {\n      assert(this._autoAllocateChunkSize === undefined);\n    }\n\n    const promise = ReadableStreamAddReadRequest(stream);\n\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n\n    return promise;\n  }\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nfunction IsReadableByteStreamController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_underlyingByteSource')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n    return undefined;\n  }\n\n  if (controller._pulling === true) {\n    controller._pullAgain = true;\n    return undefined;\n  }\n\n  assert(controller._pullAgain === false);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = PromiseInvokeOrNoop(controller._underlyingByteSource, 'pull', [controller]);\n  pullPromise.then(\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain === true) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      if (controller._controlledReadableStream._state === 'readable') {\n        ReadableByteStreamControllerError(controller, e);\n      }\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n\n  return undefined;\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = [];\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  assert(stream._state !== 'errored', 'state must not be errored');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.ctor(\n      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._totalQueuedBytes += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n\n  const maxBytesToCopy = Math.min(controller._totalQueuedBytes,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue[0];\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._totalQueuedBytes -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (ready === false) {\n    assert(controller._totalQueuedBytes === 0, 'queue must be empty');\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n  assert(controller._controlledReadableStream._state === 'readable');\n\n  if (controller._totalQueuedBytes === 0 && controller._closeRequested === true) {\n    ReadableStreamClose(controller._controlledReadableStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === undefined) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = undefined;\n  controller._byobRequest = undefined;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  assert(controller._closeRequested === false);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._totalQueuedBytes === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos[0];\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerPullInto(controller, view) {\n  const stream = controller._controlledReadableStream;\n\n  let elementSize = 1;\n  if (view.constructor !== DataView) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n\n  const ctor = view.constructor;\n\n  const pullIntoDescriptor = {\n    buffer: view.buffer,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize,\n    ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer);\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    return ReadableStreamAddReadIntoRequest(stream);\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new view.constructor(view.buffer, view.byteOffset, 0);\n    return Promise.resolve(CreateIterResultObject(emptyView, true));\n  }\n\n  if (controller._totalQueuedBytes > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      return Promise.resolve(CreateIterResultObject(filledView, false));\n    }\n\n    if (controller._closeRequested === true) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      return Promise.reject(e);\n    }\n  }\n\n  pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer);\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  const promise = ReadableStreamAddReadIntoRequest(stream);\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n\n  return promise;\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  firstDescriptor.buffer = SameRealmTransfer(firstDescriptor.buffer);\n\n  assert(firstDescriptor.bytesFilled === 0, 'bytesFilled must be 0');\n\n  const stream = controller._controlledReadableStream;\n\n  while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n    ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n    throw new RangeError('bytesWritten out of range');\n  }\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    // TODO: Figure out whether we should detach the buffer or not here.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(stream._state === 'readable');\n\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  const descriptor = controller._pendingPullIntos.shift();\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested === true) {\n    return false;\n  }\n\n  if (controller._started === false) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {\n    return true;\n  }\n\n  return false;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nfunction ReadableByteStreamControllerClose(controller) {\n  const stream = controller._controlledReadableStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  if (controller._totalQueuedBytes > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableStreamClose(stream);\n}\n\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n  const stream = controller._controlledReadableStream;\n\n  assert(controller._closeRequested === false);\n  assert(stream._state === 'readable');\n\n  const buffer = chunk.buffer;\n  const byteOffset = chunk.byteOffset;\n  const byteLength = chunk.byteLength;\n  const transferredBuffer = SameRealmTransfer(buffer);\n\n  if (ReadableStreamHasDefaultReader(stream) === true) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(IsReadableStreamLocked(stream) === false, 'stream must not be locked');\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n}\n\nfunction ReadableByteStreamControllerError(controller, e) {\n  const stream = controller._controlledReadableStream;\n\n  assert(stream._state === 'readable');\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  controller._queue = [];\n\n  ReadableStreamError(stream, e);\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._totalQueuedBytes;\n}\n\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\n    throw new RangeError('bytesWritten must be a finite');\n  }\n\n  assert(controller._pendingPullIntos.length > 0);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos[0];\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.byteLength !== view.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n\n  firstDescriptor.buffer = view.buffer;\n\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\n// Helper functions for the readers.\n\nfunction readerLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\nfunction defaultReaderClosedPromiseInitialize(reader) {\n  reader._closedPromise = new Promise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  reader._closedPromise = Promise.reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  reader._closedPromise = Promise.resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  reader._closedPromise = Promise.reject(reason);\n}\n\nfunction defaultReaderClosedPromiseResolve(reader) {\n  assert(reader._closedPromise_resolve !== undefined);\n  assert(reader._closedPromise_reject !== undefined);\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction byobReaderBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name) {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name) {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n",
    "'use strict';\nconst assert = require('assert');\nconst { InvokeOrNoop, PromiseInvokeOrPerformFallback, PromiseInvokeOrNoop, typeIsObject } = require('./helpers.js');\nconst { ReadableStream, ReadableStreamDefaultControllerClose,\n        ReadableStreamDefaultControllerEnqueue, ReadableStreamDefaultControllerError,\n        ReadableStreamDefaultControllerGetDesiredSize } = require('./readable-stream.js');\nconst { WritableStream, WritableStreamDefaultControllerError } = require('./writable-stream.js');\n\n// Methods on the transform stream controller object\n\nfunction TransformStreamCloseReadable(transformStream) {\n  // console.log('TransformStreamCloseReadable()');\n\n  if (transformStream._errored === true) {\n    throw new TypeError('TransformStream is already errored');\n  }\n\n  if (transformStream._readableClosed === true) {\n    throw new TypeError('Readable side is already closed');\n  }\n\n  TransformStreamCloseReadableInternal(transformStream);\n}\n\nfunction TransformStreamEnqueueToReadable(transformStream, chunk) {\n  // console.log('TransformStreamEnqueueToReadable()');\n\n  if (transformStream._errored === true) {\n    throw new TypeError('TransformStream is already errored');\n  }\n\n  if (transformStream._readableClosed === true) {\n    throw new TypeError('Readable side is already closed');\n  }\n\n  // We throttle transformer.transform invocation based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamEnqueueToReadable() calls.\n\n  const controller = transformStream._readableController;\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(controller, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    // The ReadableStream has already errored itself.\n    transformStream._readableClosed = true;\n    TransformStreamErrorIfNeeded(transformStream, e);\n\n    throw transformStream._storedError;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  const maybeBackpressure = desiredSize <= 0;\n\n  if (maybeBackpressure === true && transformStream._backpressure === false) {\n    // This allows pull() again. When desiredSize is 0, it's possible that a pull() will happen immediately (but\n    // asynchronously) after this because of pending read()s and set _backpressure back to false.\n    //\n    // If pull() could be called from inside enqueue(), then this logic would be wrong. This cannot happen\n    // because there is always a promise pending from start() or pull() when _backpressure is false.\n    TransformStreamSetBackpressure(transformStream, true);\n  }\n}\n\nfunction TransformStreamError(transformStream, e) {\n  if (transformStream._errored === true) {\n    throw new TypeError('TransformStream is already errored');\n  }\n\n  TransformStreamErrorInternal(transformStream, e);\n}\n\n// Abstract operations.\n\nfunction TransformStreamCloseReadableInternal(transformStream) {\n  assert(transformStream._errored === false);\n  assert(transformStream._readableClosed === false);\n\n  try {\n    ReadableStreamDefaultControllerClose(transformStream._readableController);\n  } catch (e) {\n    assert(false);\n  }\n\n  transformStream._readableClosed = true;\n}\n\nfunction TransformStreamErrorIfNeeded(transformStream, e) {\n  if (transformStream._errored === false) {\n    TransformStreamErrorInternal(transformStream, e);\n  }\n}\n\nfunction TransformStreamErrorInternal(transformStream, e) {\n  // console.log('TransformStreamErrorInternal()');\n\n  assert(transformStream._errored === false);\n\n  transformStream._errored = true;\n  transformStream._storedError = e;\n\n  if (transformStream._writableDone === false) {\n    WritableStreamDefaultControllerError(transformStream._writableController, e);\n  }\n  if (transformStream._readableClosed === false) {\n    ReadableStreamDefaultControllerError(transformStream._readableController, e);\n  }\n}\n\n// Used for preventing the next write() call on TransformStreamSink until there\n// is no longer backpressure.\nfunction TransformStreamReadableReadyPromise(transformStream) {\n  assert(transformStream._backpressureChangePromise !== undefined,\n         '_backpressureChangePromise should have been initialized');\n\n  if (transformStream._backpressure === false) {\n    return Promise.resolve();\n  }\n\n  assert(transformStream._backpressure === true, '_backpressure should have been initialized');\n\n  return transformStream._backpressureChangePromise;\n}\n\nfunction TransformStreamSetBackpressure(transformStream, backpressure) {\n  // console.log(`TransformStreamSetBackpressure(${backpressure})`);\n\n  // Passes also when called during construction.\n  assert(transformStream._backpressure !== backpressure,\n         'TransformStreamSetBackpressure() should be called only when backpressure is changed');\n\n  if (transformStream._backpressureChangePromise !== undefined) {\n    // The fulfillment value is just for a sanity check.\n    transformStream._backpressureChangePromise_resolve(backpressure);\n  }\n\n  transformStream._backpressureChangePromise = new Promise(resolve => {\n    transformStream._backpressureChangePromise_resolve = resolve;\n  });\n\n  transformStream._backpressureChangePromise.then(resolution => {\n    assert(resolution !== backpressure,\n           '_backpressureChangePromise should be fulfilled only when backpressure is changed');\n  });\n\n  transformStream._backpressure = backpressure;\n}\n\nfunction TransformStreamDefaultTransform(chunk, transformStreamController) {\n  const transformStream = transformStreamController._controlledTransformStream;\n  TransformStreamEnqueueToReadable(transformStream, chunk);\n  return Promise.resolve();\n}\n\nfunction TransformStreamTransform(transformStream, chunk) {\n  // console.log('TransformStreamTransform()');\n\n  assert(transformStream._errored === false);\n  assert(transformStream._transforming === false);\n  assert(transformStream._backpressure === false);\n\n  transformStream._transforming = true;\n\n  const transformer = transformStream._transformer;\n  const controller = transformStream._transformStreamController;\n\n  const transformPromise = PromiseInvokeOrPerformFallback(transformer, 'transform', [chunk, controller],\n                             TransformStreamDefaultTransform, [chunk, controller]);\n\n  return transformPromise.then(\n    () => {\n      transformStream._transforming = false;\n\n      return TransformStreamReadableReadyPromise(transformStream);\n    },\n    e => {\n      TransformStreamErrorIfNeeded(transformStream, e);\n      return Promise.reject(e);\n    });\n}\n\nfunction IsTransformStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsTransformStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nclass TransformStreamSink {\n  constructor(transformStream, startPromise) {\n    this._transformStream = transformStream;\n    this._startPromise = startPromise;\n  }\n\n  start(c) {\n    const transformStream = this._transformStream;\n\n    transformStream._writableController = c;\n\n    return this._startPromise.then(() => TransformStreamReadableReadyPromise(transformStream));\n  }\n\n  write(chunk) {\n    // console.log('TransformStreamSink.write()');\n\n    const transformStream = this._transformStream;\n\n    return TransformStreamTransform(transformStream, chunk);\n  }\n\n  abort() {\n    const transformStream = this._transformStream;\n    transformStream._writableDone = true;\n    TransformStreamErrorInternal(transformStream, new TypeError('Writable side aborted'));\n  }\n\n  close() {\n    // console.log('TransformStreamSink.close()');\n\n    const transformStream = this._transformStream;\n\n    assert(transformStream._transforming === false);\n\n    transformStream._writableDone = true;\n\n    const flushPromise = PromiseInvokeOrNoop(transformStream._transformer,\n                         'flush', [transformStream._transformStreamController]);\n    // Return a promise that is fulfilled with undefined on success.\n    return flushPromise.then(() => {\n      if (transformStream._errored === true) {\n        return Promise.reject(transformStream._storedError);\n      }\n      if (transformStream._readableClosed === false) {\n        TransformStreamCloseReadableInternal(transformStream);\n      }\n      return Promise.resolve();\n    }).catch(r => {\n      TransformStreamErrorIfNeeded(transformStream, r);\n      return Promise.reject(transformStream._storedError);\n    });\n  }\n}\n\nclass TransformStreamSource {\n  constructor(transformStream, startPromise) {\n    this._transformStream = transformStream;\n    this._startPromise = startPromise;\n  }\n\n  start(c) {\n    const transformStream = this._transformStream;\n\n    transformStream._readableController = c;\n\n    return this._startPromise.then(() => {\n      // Prevent the first pull() call until there is backpressure.\n\n      assert(transformStream._backpressureChangePromise !== undefined,\n             '_backpressureChangePromise should have been initialized');\n\n      if (transformStream._backpressure === true) {\n        return Promise.resolve();\n      }\n\n      assert(transformStream._backpressure === false, '_backpressure should have been initialized');\n\n      return transformStream._backpressureChangePromise;\n    });\n  }\n\n  pull() {\n    // console.log('TransformStreamSource.pull()');\n\n    const transformStream = this._transformStream;\n\n    // Invariant. Enforced by the promises returned by start() and pull().\n    assert(transformStream._backpressure === true, 'pull() should be never called while _backpressure is false');\n\n    assert(transformStream._backpressureChangePromise !== undefined,\n           '_backpressureChangePromise should have been initialized');\n\n    TransformStreamSetBackpressure(transformStream, false);\n\n    // Prevent the next pull() call until there is backpressure.\n    return transformStream._backpressureChangePromise;\n  }\n\n  cancel() {\n    const transformStream = this._transformStream;\n    transformStream._readableClosed = true;\n    TransformStreamErrorInternal(transformStream, new TypeError('Readable side canceled'));\n  }\n}\n\nclass TransformStreamDefaultController {\n  constructor(transformStream) {\n    if (IsTransformStream(transformStream) === false) {\n      throw new TypeError('TransformStreamDefaultController can only be ' +\n                          'constructed with a TransformStream instance');\n    }\n\n    if (transformStream._transformStreamController !== undefined) {\n      throw new TypeError('TransformStreamDefaultController instances can ' +\n                          'only be created by the TransformStream constructor');\n    }\n\n    this._controlledTransformStream = transformStream;\n  }\n\n  get desiredSize() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const transformStream = this._controlledTransformStream;\n    const readableController = transformStream._readableController;\n\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n\n  enqueue(chunk) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamEnqueueToReadable(this._controlledTransformStream, chunk);\n  }\n\n  close() {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    TransformStreamCloseReadable(this._controlledTransformStream);\n  }\n\n  error(reason) {\n    if (IsTransformStreamDefaultController(this) === false) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamError(this._controlledTransformStream, reason);\n  }\n}\n\nclass TransformStream {\n  constructor(transformer = {}) {\n    this._transformer = transformer;\n    const { readableStrategy, writableStrategy } = transformer;\n\n    this._transforming = false;\n    this._errored = false;\n    this._storedError = undefined;\n\n    this._writableController = undefined;\n    this._readableController = undefined;\n    this._transformStreamController = undefined;\n\n    this._writableDone = false;\n    this._readableClosed = false;\n\n    this._backpressure = undefined;\n    this._backpressureChangePromise = undefined;\n    this._backpressureChangePromise_resolve = undefined;\n\n    this._transformStreamController = new TransformStreamDefaultController(this);\n\n    let startPromise_resolve;\n    const startPromise = new Promise(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    const source = new TransformStreamSource(this, startPromise);\n\n    this._readable = new ReadableStream(source, readableStrategy);\n\n    const sink = new TransformStreamSink(this, startPromise);\n\n    this._writable = new WritableStream(sink, writableStrategy);\n\n    assert(this._writableController !== undefined);\n    assert(this._readableController !== undefined);\n\n    const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(this._readableController);\n    // Set _backpressure based on desiredSize. As there is no read() at this point, we can just interpret\n    // desiredSize being non-positive as backpressure.\n    TransformStreamSetBackpressure(this, desiredSize <= 0);\n\n    const transformStream = this;\n    const startResult = InvokeOrNoop(transformer, 'start',\n                          [transformStream._transformStreamController]);\n    startPromise_resolve(startResult);\n    startPromise.catch(e => {\n      // The underlyingSink and underlyingSource will error the readable and writable ends on their own.\n      if (transformStream._errored === false) {\n        transformStream._errored = true;\n        transformStream._storedError = e;\n      }\n    });\n  }\n\n  get readable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  get writable() {\n    if (IsTransformStream(this) === false) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\nmodule.exports = { TransformStream };\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name) {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n",
    "'use strict';\nconst assert = require('assert');\nconst { InvokeOrNoop, PromiseInvokeOrNoop, PromiseInvokeOrFallbackOrNoop, ValidateAndNormalizeQueuingStrategy,\n        typeIsObject } = require('./helpers.js');\nconst { rethrowAssertionErrorRejection } = require('./utils.js');\nconst { DequeueValue, EnqueueValueWithSize, GetTotalQueueSize, PeekQueueValue } = require('./queue-with-sizes.js');\n\nclass WritableStream {\n  constructor(underlyingSink = {}, { size, highWaterMark = 1 } = {}) {\n    this._state = 'writable';\n    this._storedError = undefined;\n\n    this._writer = undefined;\n\n    // Initialize to undefined first because the constructor of the controller checks this\n    // variable to validate the caller.\n    this._writableStreamController = undefined;\n\n    // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n    // producer without waiting for the queued writes to finish.\n    this._writeRequests = [];\n\n    // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n    // them from being erroneously rejected on error. If a write() call is pending, the request is stored here.\n    this._pendingWriteRequest = undefined;\n\n    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n    // has been detached.\n    this._pendingCloseRequest = undefined;\n\n    // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n    this._pendingAbortRequest = undefined;\n\n    const type = underlyingSink.type;\n\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    this._writableStreamController = new WritableStreamDefaultController(this, underlyingSink, size, highWaterMark);\n  }\n\n  get locked() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  abort(reason) {\n    if (IsWritableStream(this) === false) {\n      return Promise.reject(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this) === true) {\n      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  getWriter() {\n    if (IsWritableStream(this) === false) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nmodule.exports = {\n  AcquireWritableStreamDefaultWriter,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerError,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter(stream) {\n  return new WritableStreamDefaultWriter(stream);\n}\n\nfunction IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction IsWritableStreamLocked(stream) {\n  assert(IsWritableStream(stream) === true, 'IsWritableStreamLocked should only be used on known writable streams');\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream, reason) {\n  const state = stream._state;\n  if (state === 'closed') {\n    return Promise.resolve(undefined);\n  }\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'closing');\n\n  const error = new TypeError('Aborted');\n\n  WritableStreamError(stream, error);\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n  if (controller._writing === true || controller._inClose === true) {\n    const promise = new Promise((resolve, reject) => {\n      const abortRequest = {\n        _resolve: resolve,\n        _reject: reject\n      };\n\n      stream._pendingAbortRequest = abortRequest;\n    });\n    if (controller._writing === true) {\n      return promise.then(() => WritableStreamDefaultControllerAbort(stream._writableStreamController, reason));\n    }\n    return promise;\n  }\n\n  return WritableStreamDefaultControllerAbort(stream._writableStreamController, reason);\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream) {\n  assert(IsWritableStreamLocked(stream) === true);\n  assert(stream._state === 'writable');\n\n  const promise = new Promise((resolve, reject) => {\n    const writeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamError(stream, e) {\n  const oldState = stream._state;\n  assert(oldState === 'writable' || oldState === 'closing');\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const controller = stream._writableStreamController;\n  // This method can be called during the construction of the controller, in which case \"controller\" will be undefined\n  // but the flags are guaranteed to be false anyway.\n  if (controller === undefined || controller._writing === false && controller._inClose === false) {\n    WritableStreamRejectPromisesInReactionToError(stream);\n  }\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    if (oldState === 'writable' &&\n        WritableStreamDefaultControllerGetBackpressure(stream._writableStreamController) === true) {\n      defaultWriterReadyPromiseReject(writer, e);\n    } else {\n      defaultWriterReadyPromiseResetToRejected(writer, e);\n    }\n    writer._readyPromise.catch(() => {});\n  }\n}\n\nfunction WritableStreamFinishClose(stream) {\n  assert(stream._state === 'closing' || stream._state === 'errored');\n\n  if (stream._state === 'closing') {\n    defaultWriterClosedPromiseResolve(stream._writer);\n    stream._state = 'closed';\n  } else {\n    assert(stream._state === 'errored');\n    defaultWriterClosedPromiseReject(stream._writer, stream._storedError);\n    stream._writer._closedPromise.catch(() => {});\n  }\n\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._resolve();\n    stream._pendingAbortRequest = undefined;\n  }\n}\n\nfunction WritableStreamRejectPromisesInReactionToError(stream) {\n  assert(stream._state === 'errored');\n  assert(stream._pendingWriteRequest === undefined);\n\n  const storedError = stream._storedError;\n  for (const writeRequest of stream._writeRequests) {\n    writeRequest._reject(storedError);\n  }\n  stream._writeRequests = [];\n\n  if (stream._pendingCloseRequest !== undefined) {\n    assert(stream._writableStreamController._inClose === false);\n    stream._pendingCloseRequest._reject(storedError);\n    stream._pendingCloseRequest = undefined;\n  }\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, storedError);\n    writer._closedPromise.catch(() => {});\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n  assert(stream._state === 'writable');\n\n  const writer = stream._writer;\n  if (writer === undefined) {\n    return;\n  }\n\n  if (backpressure === true) {\n    defaultWriterReadyPromiseReset(writer);\n  } else {\n    assert(backpressure === false);\n    defaultWriterReadyPromiseResolve(writer);\n  }\n}\n\nclass WritableStreamDefaultWriter {\n  constructor(stream) {\n    if (IsWritableStream(stream) === false) {\n      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\n    }\n    if (IsWritableStreamLocked(stream) === true) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable' || state === 'closing') {\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored', 'state must be errored');\n\n      defaultWriterClosedPromiseInitializeAsRejected(this, stream._storedError);\n      this._closedPromise.catch(() => {});\n    }\n\n    if (state === 'writable' &&\n        WritableStreamDefaultControllerGetBackpressure(stream._writableStreamController) === true) {\n      defaultWriterReadyPromiseInitialize(this);\n    } else {\n      defaultWriterReadyPromiseInitializeAsResolved(this, undefined);\n    }\n  }\n\n  get closed() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  get desiredSize() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  get ready() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  abort(reason) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return Promise.reject(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  close() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return Promise.reject(defaultWriterLockException('close'));\n    }\n\n    if (stream._state === 'closing') {\n      return Promise.reject(new TypeError('cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  releaseLock() {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  write(chunk) {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n      return Promise.reject(defaultWriterBrandCheckException('write'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return Promise.reject(defaultWriterLockException('write to'));\n    }\n\n    if (stream._state === 'closing') {\n      return Promise.reject(new TypeError('Cannot write to an already-closed stream'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return true;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.reject(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable');\n\n  const promise = new Promise((resolve, reject) => {\n    const closeRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._pendingCloseRequest = closeRequest;\n  });\n\n  if (WritableStreamDefaultControllerGetBackpressure(stream._writableStreamController) === true) {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  stream._state = 'closing';\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (state === 'closing' || state === 'closed') {\n    return Promise.resolve();\n  }\n\n  if (state === 'errored') {\n    return Promise.reject(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    'Writer was released and can no longer be used to monitor the stream\\'s closedness');\n  const state = stream._state;\n\n  if (state === 'writable' || state === 'closing' || stream._pendingAbortRequest !== undefined) {\n    defaultWriterClosedPromiseReject(writer, releasedError);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, releasedError);\n  }\n  writer._closedPromise.catch(() => {});\n\n  if (state === 'writable' &&\n      WritableStreamDefaultControllerGetBackpressure(stream._writableStreamController) === true) {\n    defaultWriterReadyPromiseReject(writer, releasedError);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, releasedError);\n  }\n  writer._readyPromise.catch(() => {});\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined;\n}\n\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return Promise.reject(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be written to`));\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(stream._writableStreamController, chunk);\n\n  return promise;\n}\n\nclass WritableStreamDefaultController {\n  constructor(stream, underlyingSink, size, highWaterMark) {\n    if (IsWritableStream(stream) === false) {\n      throw new TypeError('WritableStreamDefaultController can only be constructed with a WritableStream instance');\n    }\n\n    if (stream._writableStreamController !== undefined) {\n      throw new TypeError(\n        'WritableStreamDefaultController instances can only be created by the WritableStream constructor');\n    }\n\n    this._controlledWritableStream = stream;\n\n    this._underlyingSink = underlyingSink;\n\n    this._queue = [];\n    this._started = false;\n    this._writing = false;\n    this._inClose = false;\n\n    const normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);\n    this._strategySize = normalizedStrategy.size;\n    this._strategyHWM = normalizedStrategy.highWaterMark;\n\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(this);\n    if (backpressure === true) {\n      WritableStreamUpdateBackpressure(stream, backpressure);\n    }\n\n    const controller = this;\n\n    const startResult = InvokeOrNoop(underlyingSink, 'start', [this]);\n    Promise.resolve(startResult).then(\n      () => {\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      },\n      r => {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, r);\n      }\n    )\n    .catch(rethrowAssertionErrorRejection);\n  }\n\n  error(e) {\n    if (IsWritableStreamDefaultController(this) === false) {\n      throw new TypeError(\n        'WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n    }\n\n    const state = this._controlledWritableStream._state;\n    if (state === 'closed' || state === 'errored') {\n      throw new TypeError(`The stream is ${state} and so cannot be errored`);\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction WritableStreamDefaultControllerAbort(controller, reason) {\n  controller._queue = [];\n\n  const sinkAbortPromise = PromiseInvokeOrFallbackOrNoop(controller._underlyingSink, 'abort', [reason],\n                                                         'close', [controller]);\n  return sinkAbortPromise.then(() => undefined);\n}\n\nfunction WritableStreamDefaultControllerClose(controller) {\n  EnqueueValueWithSize(controller._queue, 'close', 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n  const queueSize = GetTotalQueueSize(controller._queue);\n  return controller._strategyHWM - queueSize;\n}\n\nfunction WritableStreamDefaultControllerWrite(controller, chunk) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  let chunkSize = 1;\n\n  if (controller._strategySize !== undefined) {\n    try {\n      chunkSize = controller._strategySize(chunk);\n    } catch (chunkSizeE) {\n      // TODO: Should we notify the sink of this error?\n      WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n      return;\n    }\n  }\n\n  const writeRecord = { chunk };\n\n  const lastBackpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n\n  try {\n    EnqueueValueWithSize(controller._queue, writeRecord, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  if (stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    if (lastBackpressure !== backpressure) {\n      WritableStreamUpdateBackpressure(stream, backpressure);\n    }\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction IsWritableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_underlyingSink')) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  if (controller._controlledWritableStream._state === 'closed' ||\n      controller._controlledWritableStream._state === 'errored') {\n    return;\n  }\n\n  if (controller._started === false) {\n    return;\n  }\n\n  if (controller._writing === true) {\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const writeRecord = PeekQueueValue(controller._queue);\n  if (writeRecord === 'close') {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, e) {\n  if (controller._controlledWritableStream._state === 'writable' ||\n      controller._controlledWritableStream._state === 'closing') {\n    WritableStreamDefaultControllerError(controller, e);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'closing', 'can\\'t process final write record unless already closed');\n\n  DequeueValue(controller._queue);\n  assert(controller._queue.length === 0, 'queue must be empty once the final write record is dequeued');\n\n  controller._inClose = true;\n  const sinkClosePromise = PromiseInvokeOrNoop(controller._underlyingSink, 'close', [controller]);\n  sinkClosePromise.then(\n    () => {\n      assert(controller._inClose === true);\n      controller._inClose = false;\n      if (stream._state !== 'closing' && stream._state !== 'errored') {\n        return;\n      }\n\n      assert(stream._pendingCloseRequest !== undefined);\n      stream._pendingCloseRequest._resolve(undefined);\n      stream._pendingCloseRequest = undefined;\n\n      WritableStreamFinishClose(stream);\n    },\n    r => {\n      assert(controller._inClose === true);\n      controller._inClose = false;\n      assert(stream._pendingCloseRequest !== undefined);\n      stream._pendingCloseRequest._reject(r);\n      stream._pendingCloseRequest = undefined;\n      if (stream._pendingAbortRequest !== undefined) {\n        stream._pendingAbortRequest._reject(r);\n        stream._pendingAbortRequest = undefined;\n      }\n      WritableStreamDefaultControllerErrorIfNeeded(controller, r);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n  controller._writing = true;\n\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._pendingWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._pendingWriteRequest = stream._writeRequests.shift();\n  const sinkWritePromise = PromiseInvokeOrNoop(controller._underlyingSink, 'write', [chunk, controller]);\n  sinkWritePromise.then(\n    () => {\n      const state = stream._state;\n\n      assert(controller._writing === true);\n      controller._writing = false;\n\n      assert(stream._pendingWriteRequest !== undefined);\n      stream._pendingWriteRequest._resolve(undefined);\n      stream._pendingWriteRequest = undefined;\n\n      if (state === 'errored') {\n        WritableStreamRejectPromisesInReactionToError(stream);\n\n        if (stream._pendingAbortRequest !== undefined) {\n          stream._pendingAbortRequest._resolve();\n          stream._pendingAbortRequest = undefined;\n        }\n        return;\n      }\n      const lastBackpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n      DequeueValue(controller._queue);\n      if (state !== 'closing') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        if (lastBackpressure !== backpressure) {\n          WritableStreamUpdateBackpressure(controller._controlledWritableStream, backpressure);\n        }\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    r => {\n      assert(controller._writing === true);\n      controller._writing = false;\n\n      assert(stream._pendingWriteRequest !== undefined);\n      stream._pendingWriteRequest._reject(r);\n      stream._pendingWriteRequest = undefined;\n      if (stream._state === 'errored') {\n        stream._storedError = r;\n        WritableStreamRejectPromisesInReactionToError(stream);\n      }\n      if (stream._pendingAbortRequest !== undefined) {\n        stream._pendingAbortRequest._reject(r);\n        stream._pendingAbortRequest = undefined;\n      }\n      WritableStreamDefaultControllerErrorIfNeeded(controller, r);\n    }\n  )\n  .catch(rethrowAssertionErrorRejection);\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller, e) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable' || stream._state === 'closing');\n\n  WritableStreamError(stream, e);\n\n  controller._queue = [];\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name) {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name) {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer) {\n  writer._closedPromise = new Promise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  writer._closedPromise = Promise.reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  writer._closedPromise = Promise.resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n}\n\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n\n  writer._closedPromise = Promise.reject(reason);\n}\n\nfunction defaultWriterClosedPromiseResolve(writer) {\n  assert(writer._closedPromise_resolve !== undefined);\n  assert(writer._closedPromise_reject !== undefined);\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer) {\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  writer._readyPromise = Promise.resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n}\n\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n}\n\nfunction defaultWriterReadyPromiseReset(writer) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = new Promise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  writer._readyPromise = Promise.reject(reason);\n}\n\nfunction defaultWriterReadyPromiseResolve(writer) {\n  assert(writer._readyPromise_resolve !== undefined);\n  assert(writer._readyPromise_reject !== undefined);\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n}\n"
  ]
}